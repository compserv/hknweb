{% extends 'base.html' %}

{% block title %}Course Guide{% endblock %}

{% block header %}
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="//d3js.org/d3-scale-chromatic.v0.3.min.js"></script>
    <style>
        .graph {
            display: block;
            text-align: center;
            margin: auto;
            background-color: ghostwhite;
        }
        /* .links line {
            stroke: #aaa;
        } */
        .nodes circle {
            pointer-events: all;
        }
        .group_selection {
            text-align: center;
            font-size: 125%;
        }
        .svg-container { /* Questionable display on phones possibly? */
            width: 100%;
            overflow: hidden;
        }
        .graph {
            width: 100%;
            height: auto;
        }
    </style>
    <script>
        function action(group) {
            const urlParams = new URLSearchParams(window.location.search);
            var groups = urlParams.get("groups") || "Core";
            groups = groups.split(",");
            const checkbox = document.getElementById(group);
            if (checkbox.checked) {
                groups.push(group);
            } else {
                const idx = groups.indexOf(group);
                if (idx > -1) groups.splice(idx, 1);
            }
            groups = groups.join();
            if (history.pushState) {
                const newurl = window.location.origin + window.location.pathname + "?groups=" + groups;
                window.history.replaceState({path: newurl}, "", newurl);
            }
            window.location = window.location;
        }
    </script>
{% endblock %}

{% block heading %}Course Guide{% endblock %}

{% block content %}
    <div class="group_selection">
        {% for group in groups %}
            <input type="checkbox"
                   id="{{ group }}"
                   {% if group in request.GET.groups %} checked {% endif %}
                   onclick="action('{{ group }}')"> {{ group }}
        {% endfor %}
    </div>

    <h2 style="text-align: center;">
        Get a description of each EECS Academic Area here:
        <a href="https://www2.eecs.berkeley.edu/Research/Areas/">EECS Research Areas</a>
    </h2>

    <h2 style="text-align: center;">
        <a href="/static/img/course-map-2019.png">Image version of the Course Guide</a>
    </h2>

    <div class="svg-container">
        <svg class="graph"
             viewBox="0 0 2000 1200"
             preserveAspectRatio="xMidYMid meet">
        </svg>
    </div>

    <script>
        var svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height"),
            circle_radius = {{ params.circle_radius }},
            title_circle_radius = circle_radius * 1.25,
            node_stroke_width = 1,
            node_stroke = "gray";

        const color = d3.scaleOrdinal(d3.schemeSet2);
        for (let i = 1; i <= {{ groups|length }} + 1; i++) color(i);

        function renderd3(groups) {
            d3.json("{% url 'studentservices:course_guide_data' %}?groups=" + groups, function(error, graph) {
                if (error) throw error;

                const bbox  = svg.node().getBoundingClientRect(),
                      width = bbox.width,
                      height= bbox.height,
                      padding = circle_radius * 2;

                const nodeById = new Map(graph.nodes.map(d => [d.id, d])),
                      children = new Map(graph.nodes.map(d => [d.id, []]));

                graph.links.forEach(l => {
                    const s = (typeof l.source === "object" ? l.source.id : l.source),
                          t = (typeof l.target === "object" ? l.target.id : l.target);
                    children.get(s).push(t);
                });

                const inDegree = new Map(graph.nodes.map(d => [d.id, 0]));
                graph.links.forEach(l => {
                    const tgt = (typeof l.target === "object" ? l.target.id : l.target);
                    inDegree.set(tgt, inDegree.get(tgt) + 1);
                });

                const queue = [];
                inDegree.forEach((deg, id) => { if (deg === 0) queue.push(id); });
                const depth = new Map(queue.map(id => [id, 0]));

                while (queue.length) {
                    const id0   = queue.shift(),
                          dep0 = depth.get(id0);
                    children.get(id0).forEach(childId => {
                        depth.set(childId, Math.max(depth.get(childId) || 0, dep0 + 1));
                        inDegree.set(childId, inDegree.get(childId) - 1);
                        if (inDegree.get(childId) === 0) queue.push(childId);
                    });
                }

                const layers = {};
                graph.nodes.forEach(d => {
                    const dep = depth.get(d.id) || 0;
                    if (!layers[dep]) layers[dep] = [];
                    layers[dep].push(d);
                });

                const vSpacing = circle_radius * 4;
                Object.keys(layers).forEach(key => {
                    const dep  = +key,
                          row  = layers[dep],
                          hGap = (width  - 2 * padding) / (row.length + 1);

                    row.forEach((node, i) => {
                        node.x = padding + (i + 1) * hGap;
                        node.y = dep === 0
                               ? padding
                               : padding + dep * vSpacing;
                    });
                });

                const defs = svg.insert("defs", ":first-child");
                const arrowhead_size = link_stroke_width*1.5;

                for (let i = 1; i <= {{ groups|length }}; i++) {
                    defs.append("marker")
                        .attr("id", `head-${i}`)
                        .attr("viewBox", `0 -${arrowhead_size} ${arrowhead_size*2} ${arrowhead_size*2}`)
                        .attr("markerUnits", "userSpaceOnUse") 
                        .attr("refX", circle_radius + arrowhead_size*1.5) 
                        .attr("refY", 0)
                        .attr("markerWidth", arrowhead_size*2)
                        .attr("markerHeight", arrowhead_size*2)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", `M 0 -${arrowhead_size} L ${arrowhead_size*2} 0 L 0 ${arrowhead_size}`)
                        .attr("fill", color(i));
                }

                const link = svg.append("g")
                    .attr("class", "links")
                  .selectAll("line")
                    .data(graph.links)
                  .enter().append("path")
                    .attr("fill", "none")
                    .attr("stroke-width", link_stroke_width)
                    .attr("stroke", d => color(
                        nodeById.get(
                            typeof d.source === "object" ? d.source.id : d.source
                        ).group))
                    .attr("marker-end", d => {
                        const g = nodeById.get(
                            typeof d.source==="object" ? d.source.id : d.source
                        ).group;
                        return `url(#head-${g})`;
                    })
                    .attr("d", d => {
                        let source = nodeById.get( typeof d.source === "object" ? d.source.id : d.source );
                        let target = nodeById.get( typeof d.target === "object" ? d.target.id : d.target );
                        return `M ${source.x} ${source.y} L ${target.x} ${target.y}`;
                    });

                const node = svg.append("g")
                    .attr("class", "nodes")
                  .selectAll("g")
                    .data(graph.nodes)
                  .enter().append("g")
                    .attr("transform", d => `translate(${d.x},${d.y})`);

                node.append("circle")
                    .attr("r", d => d.title ? title_circle_radius : circle_radius)
                    .attr("fill", d => color(d.group))
                    .attr("stroke", node_stroke)
                    .attr("stroke-width", node_stroke_width);

                node.append("a")
                    .attr("xlink:href", d => d.link)
                    .attr("target", "_blank")
                  .append("text")
                    .text(d => d.id)
                    .attr("text-anchor", "middle")
                    .attr("y", 5);

                node.append("title")
                    .text(d => d.id);

                node.on("mouseover", function(d) {
                    svg.selectAll("circle")
                        .filter(d2 => d2.id !== d.id)
                        .attr("opacity", 0.6);
                    svg.selectAll("circle")
                        .filter(d2 => d2.id === d.id)
                        .attr("stroke", "black")
                        .attr("stroke-width", node_stroke_width * 3);
                    link.filter(l => {
                        const sGrp = typeof l.source === "object" ? l.source.group : null;
                        const tGrp = typeof l.target === "object" ? l.target.group : null;
                        return (sGrp !== d.group && tGrp !== d.group);
                    })
                        .attr("opacity", 0.1);
                    svg.selectAll("text")
                        .filter(d2 => d2.group !== d.group)
                        .attr("opacity", 0.5);
                    svg.selectAll("text")
                        .filter(d2 => d2.id === d.id)
                        .attr("font-weight", "bold");
                })
                .on("mouseout", function() {
                    svg.selectAll("circle")
                        .attr("opacity", 1)
                        .attr("stroke", node_stroke)
                        .attr("stroke-width", node_stroke_width);
                    link.attr("opacity", 1);
                    svg.selectAll("text")
                        .attr("opacity", 1)
                        .attr("font-weight", "normal");
                });

                // Set the stroke width back to normal when mouse leaves the node.
                node.on("mouseout", function() {
                    circles.attr("opacity", 1.0);
                    link.attr("opacity", 1.0);
                    labels.attr("opacity", 1.0);
                });

                svg.append("svg:defs").selectAll("marker")
                    .data(["end", "end_title"])
                    .enter().append("svg:marker")
                        .attr("id", String)
                        .attr("viewBox", "0 -5 10 10")
                        .attr("markerUnits", "userSpaceOnUse")
                        .attr("refX", circle_radius + 5)
                        .attr("refY", 0)
                        .attr("markerWidth", {{ params.marker_width }})
                        .attr("markerHeight", {{ params.marker_height }})
                        .attr("orient", "auto")
                    .append("svg:path")
                        .attr("d", "M0,-5L10,0L0,5");
                svg.select("marker#end_title")
                    .attr("markerUnits", "userSpaceOnUse")
                    .attr("refX", title_circle_radius + 10)

                simulation
                    .nodes(graph.nodes)
                    .on("tick", ticked);

                simulation.force("link")
                    .links(graph.links);
                
                function inside_border(d, dim_size, d_coord) {
                    let radius = (d.title) ? title_circle_radius : circle_radius;
                    return Math.max(radius, Math.min(dim_size - radius, d_coord));
                };

                function ticked() {
                    node
                        .attr("cx", function(d) {
                            d.x = inside_border(d, width, d.x);
                            return d.x;
                        })
                        .attr("cy", function(d) {
                            d.y = inside_border(d, height, d.y);
                            if (d.group != 1) {
                                d.y = Math.max(d.y, 400);
                            }
                            return d.y;
                        })
                        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
                    link
                        .attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });
                }
            });
        }

        renderd3("{{ request.GET.groups }}");
    </script>
{% endblock %}
